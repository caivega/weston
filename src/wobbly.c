/*
 * Copyright © 2005 Novell, Inc.
 * Copyright © 2014 Scott Moreau
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without
 * fee, provided that the above copyright notice appear in all copies
 * and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of
 * Novell, Inc. not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 * Novell, Inc. makes no representations about the suitability of this
 * software for any purpose. It is provided "as is" without express or
 * implied warranty.
 *
 * NOVELL, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
 * NO EVENT SHALL NOVELL, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author: David Reveman <davidr@novell.com>
 *         Scott Moreau  <oreaus@gmail.com>
 */

/*
 * Spring model implemented by Kristian Hogsberg.
 */

#include <values.h>

#include "compositor.h"
#include "gl-renderer.h"

#define WOBBLY_FRICTION 3
#define WOBBLY_SPRING_K 8

#define GRID_WIDTH  4
#define GRID_HEIGHT 4

#define MODEL_MAX_SPRINGS (GRID_WIDTH * GRID_HEIGHT * 2)

#define MASS 50.0f

typedef struct _xy_pair {
	float	x, y;
} Point, Vector;

typedef struct _Edge {
	float	next, prev;

	float	start;
	float	end;

	float	attract;
	float	velocity;
} Edge;

typedef struct _Object {
	Vector	force;
	Point	position;
	Vector	velocity;
	float	theta;
	int	immobile;
	Edge	vertEdge;
	Edge	horzEdge;
} Object;

typedef struct _Spring {
	Object	*a;
	Object	*b;
	Vector	offset;
} Spring;

typedef struct _Model {
	Object	*objects;
	int	numObjects;
	Spring	springs[MODEL_MAX_SPRINGS];
	int	numSprings;
	Object	*anchorObject;
	float	steps;
	Point	topLeft;
	Point	bottomRight;
	int	bbox_current;
	pixman_region32_t bbox;
} Model;

typedef struct _WobblyWindow {
	Model		*model;
	int		wobbly;
	int		grabbed;
	int		velocity;
	int		iw, ih;
	unsigned int	state;
} WobblyWindow;

struct surface {
	WobblyWindow *ww;
	struct weston_surface *surface;
	struct weston_transform transform;
	float	x, y, cx, cy;
	float	last_x, last_y;
	int	width, height;
	int	x_cells, y_cells;
	int	synced;

	struct wl_list link;
};

struct {
	struct wl_list surface_list;
} wobbly;

static struct surface *
get_surface(struct weston_surface *surface)
{
	struct surface *ws;

	wl_list_for_each(ws, &wobbly.surface_list, link)
		if (ws->surface == surface)
			return ws;

	return NULL;
}

static struct surface *
get_wobbly_surface(struct weston_surface *surface)
{
	struct surface *ws, *next;

	wl_list_for_each_safe(ws, next, &wobbly.surface_list, link)
		if ((ws = get_surface(surface)) &&
			(ws->ww->grabbed || !ws->synced))
			return ws;

	return NULL;
}

#define WobblyInitial	(1L << 0)
#define WobblyForce	(1L << 1)
#define WobblyVelocity	(1L << 2)

static void
objectInit(Object *object,
		float  positionX,
		float  positionY,
		float  velocityX,
		float  velocityY)
{
	object->force.x = 0;
	object->force.y = 0;

	object->position.x = positionX;
	object->position.y = positionY;

	object->velocity.x = velocityX;
	object->velocity.y = velocityY;

	object->theta	= 0;
	object->immobile = 0;

	object->vertEdge.next = 0.0f;
	object->horzEdge.next = 0.0f;
}

static void
springInit(Spring *spring,
		Object *a,
		Object *b,
		float  offsetX,
		float  offsetY)
{
	spring->a		 = a;
	spring->b		 = b;
	spring->offset.x = offsetX;
	spring->offset.y = offsetY;
}

static void
modelCalcBounds(Model *model)
{
	int i;

	model->topLeft.x	 = MAXSHORT;
	model->topLeft.y	 = MAXSHORT;
	model->bottomRight.x = MINSHORT;
	model->bottomRight.y = MINSHORT;

	for (i = 0; i < model->numObjects; i++)
	{
		if (model->objects[i].position.x < model->topLeft.x)
			model->topLeft.x = model->objects[i].position.x;
		else if (model->objects[i].position.x > model->bottomRight.x)
			model->bottomRight.x = model->objects[i].position.x;

		if (model->objects[i].position.y < model->topLeft.y)
			model->topLeft.y = model->objects[i].position.y;
		else if (model->objects[i].position.y > model->bottomRight.y)
			model->bottomRight.y = model->objects[i].position.y;
	}
}

static void
modelAddSpring(Model  *model,
		Object *a,
		Object *b,
		float  offsetX,
		float  offsetY)
{
	Spring *spring;

	spring = &model->springs[model->numSprings];
	model->numSprings++;

	springInit(spring, a, b, offsetX, offsetY);
}

static void
modelSetMiddleAnchor(Model *model,
			  int   x,
			  int   y,
			  int   width,
			  int   height)
{
	float gx, gy;

	gx = ((GRID_WIDTH  - 1) / 2 * width)  / (float) (GRID_WIDTH  - 1);
	gy = ((GRID_HEIGHT - 1) / 2 * height) / (float) (GRID_HEIGHT - 1);

	if (model->anchorObject)
		model->anchorObject->immobile = 0;

	model->anchorObject = &model->objects[GRID_WIDTH *
					  ((GRID_HEIGHT - 1) / 2) +
					  (GRID_WIDTH - 1) / 2];
	model->anchorObject->position.x = x + gx;
	model->anchorObject->position.y = y + gy;

	model->anchorObject->immobile = 1;
}

static void
modelInitObjects(Model *model,
		  int	x,
		  int   y,
		  int	width,
		  int	height)
{
	int gridX, gridY, i = 0;
	float gw, gh;

	gw = GRID_WIDTH  - 1;
	gh = GRID_HEIGHT - 1;

	for (gridY = 0; gridY < GRID_HEIGHT; gridY++)
	{
		for (gridX = 0; gridX < GRID_WIDTH; gridX++)
		{
			objectInit(&model->objects[i],
				x + (gridX * width) / gw,
				y + (gridY * height) / gh,
				0, 0);
			i++;
		}
	}

	modelSetMiddleAnchor(model, x, y, width, height);
}

static void
modelInitSprings(Model *model,
		  int   x,
		  int   y,
		  int   width,
		  int   height)
{
	int   gridX, gridY, i = 0;
	float hpad, vpad;

	model->numSprings = 0;

	hpad = ((float) width) / (GRID_WIDTH  - 1);
	vpad = ((float) height) / (GRID_HEIGHT - 1);

	for (gridY = 0; gridY < GRID_HEIGHT; gridY++)
	{
		for (gridX = 0; gridX < GRID_WIDTH; gridX++)
		{
			if (gridX > 0)
				modelAddSpring(model,
						&model->objects[i - 1],
						&model->objects[i],
						hpad, 0);

			if (gridY > 0)
				modelAddSpring(model,
						&model->objects[i - GRID_WIDTH],
						&model->objects[i],
						0, vpad);

			i++;
		}
	}
}

static Model *
createModel(int	  x,
		 int	  y,
		 int	  width,
		 int	  height)
{
	Model *model;

	model = zalloc(sizeof (Model));
	if (!model)
		return 0;

	model->numObjects = GRID_WIDTH * GRID_HEIGHT;
	model->objects = zalloc(sizeof (Object) * model->numObjects);
	if (!model->objects)
	{
		free(model);
		return 0;
	}

	model->anchorObject = 0;
	model->numSprings = 0;

	model->steps = 0;

	modelInitObjects(model, x, y, width, height);
	modelInitSprings(model, x, y, width, height);

	modelCalcBounds(model);

	pixman_region32_init(&model->bbox);
	model->bbox_current = 0;

	return model;
}

static void
objectApplyForce(Object *object,
		  float  fx,
		  float  fy)
{
	object->force.x += fx;
	object->force.y += fy;
}

static void
springExertForces(Spring *spring,
		   float  k)
{
	Vector da, db;
	Vector a, b;

	a = spring->a->position;
	b = spring->b->position;

	da.x = 0.5f * (b.x - a.x - spring->offset.x);
	da.y = 0.5f * (b.y - a.y - spring->offset.y);

	db.x = 0.5f * (a.x - b.x + spring->offset.x);
	db.y = 0.5f * (a.y - b.y + spring->offset.y);

	objectApplyForce(spring->a, k * da.x, k * da.y);
	objectApplyForce(spring->b, k * db.x, k * db.y);
}

static float
modelStepObject(Model		*model,
		 Object		*object,
		 float		friction,
		 float		*force)
{
	object->theta += 0.05f;

	if (object->immobile)
	{
		object->velocity.x = 0.0f;
		object->velocity.y = 0.0f;

		object->force.x = 0.0f;
		object->force.y = 0.0f;

		*force = 0.0f;

		return 0.0f;
	} else {
		object->force.x -= friction * object->velocity.x;
		object->force.y -= friction * object->velocity.y;

		object->velocity.x += object->force.x / MASS;
		object->velocity.y += object->force.y / MASS;

		object->position.x += object->velocity.x;
		object->position.y += object->velocity.y;

		*force = fabs(object->force.x) + fabs(object->force.y);

		object->force.x = 0.0f;
		object->force.y = 0.0f;

		return fabs(object->velocity.x) + fabs(object->velocity.y);
	}
}

static int
modelStep(Model	  *model,
	   float	  friction,
	   float	  k,
	   float	  time)
{
	int   i, j, steps, wobbly = 0;
	float velocitySum = 0.0f;
	float force, forceSum = 0.0f;

	model->steps += time / 15.0f;
	steps = floor(model->steps);
	model->steps -= steps;

	if (!steps)
		return 1;

	for (j = 0; j < steps; j++)
	{
		for (i = 0; i < model->numSprings; i++)
			springExertForces(&model->springs[i], k);

		for (i = 0; i < model->numObjects; i++)
		{
			velocitySum += modelStepObject(model,
							&model->objects[i],
							friction,
							&force);
			forceSum += force;
		}
	}

	modelCalcBounds(model);

	if (velocitySum > 0.3f)
		wobbly |= WobblyVelocity;

	if (forceSum > 15.0f)
		wobbly |= WobblyForce;

	return wobbly;
}

static void
bezierPatchEvaluate(Model *model,
			 float u,
			 float v,
			 float *patchX,
			 float *patchY)
{
	float coeffsU[4], coeffsV[4];
	float x, y;
	int   i, j;

	coeffsU[0] = (1 - u) * (1 - u) * (1 - u);
	coeffsU[1] = 3 * u * (1 - u) * (1 - u);
	coeffsU[2] = 3 * u * u * (1 - u);
	coeffsU[3] = u * u * u;

	coeffsV[0] = (1 - v) * (1 - v) * (1 - v);
	coeffsV[1] = 3 * v * (1 - v) * (1 - v);
	coeffsV[2] = 3 * v * v * (1 - v);
	coeffsV[3] = v * v * v;

	x = y = 0.0f;

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			x += coeffsU[i] * coeffsV[j] *
			model->objects[j * GRID_WIDTH + i].position.x;
			y += coeffsU[i] * coeffsV[j] *
			model->objects[j * GRID_HEIGHT + i].position.y;
		}
	}

	*patchX = x;
	*patchY = y;
}

static int
wobblyEnsureModel(struct surface *surface)
{
	WobblyWindow *ww = surface->ww;

	if (!ww->model)
	{
		ww->model = createModel(surface->x, surface->y, surface->width, surface->height);
		if (!ww->model)
			return 0;
	}

	return 1;
}

static float
objectDistance(Object *object,
		float  x,
		float  y)
{
	float dx, dy;

	dx = object->position.x - x;
	dy = object->position.y - y;

	return sqrt(dx * dx + dy * dy);
}

static Object *
modelFindNearestObject(Model *model,
			float x,
			float y)
{
	Object *object = &model->objects[0];
	float  distance, minDistance = 0.0;
	int	i;

	for (i = 0; i < model->numObjects; i++)
	{
		distance = objectDistance(&model->objects[i], x, y);
		if (i == 0 || distance < minDistance)
		{
			minDistance = distance;
			object = &model->objects[i];
		}
	}

	return object;
}

static void
wobbly_compute_bbox(struct weston_view *view, pixman_region32_t *bbox)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;
	WobblyWindow *ww;
	Model *model;

	if (!(ws = get_wobbly_surface(surface)))
		return;

	ww = ws->ww;
	model = ww->model;

	if (ww->model && ww->wobbly && model->bbox_current) {
		bbox->extents.x1 = model->bbox.extents.x1;
		bbox->extents.y1 = model->bbox.extents.y1;
		bbox->extents.x2 = model->bbox.extents.x2;
		bbox->extents.y2 = model->bbox.extents.y2;
		model->bbox_current = 0;
	}
}

static void
wobbly_prepare_paint(struct weston_view *view, int msSinceLastPaint, int *needs_paint)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;
	WobblyWindow *ww;
	float  friction, springK;

	*needs_paint = 1;

	if (!(ws = get_wobbly_surface(surface)))
		return;

	ww = ws->ww;

	friction = WOBBLY_FRICTION;
	springK  = WOBBLY_SPRING_K;

	if (ww->wobbly)
	{
		if (ww->wobbly & (WobblyInitial | WobblyVelocity | WobblyForce))
		{
			ww->wobbly = modelStep(ww->model, friction, springK,
						(ww->wobbly & WobblyVelocity) ?
						msSinceLastPaint : 16);

			if (ww->wobbly) {
				modelCalcBounds(ww->model);
				*needs_paint = 0;
			} else {
				wl_list_remove(&ws->transform.link);
				wl_list_init(&ws->transform.link);
				ws->synced = 1;
			}
		}
	}
}

static void
wobbly_add_geometry(struct weston_view *view)
{
	struct weston_surface *surface = view->surface;
	struct gl_renderer *gr = get_renderer(surface->compositor);
	struct surface *ws;
	WobblyWindow *ww;
	float	width, height;
	float	cell_w, cell_h;
	float	deformedX, deformedY;
	int	x, y;
	GLfloat *v;

	if (!(ws = get_wobbly_surface(surface)))
		return;

	ww = ws->ww;

	if (ww->wobbly)
	{
		width  = ws->width;
		height = ws->height;

		cell_w = width / ws->x_cells;
		cell_h = height / ws->y_cells;

		ww->iw = ws->x_cells + 1;
		ww->ih = ws->y_cells + 1;

		v = wl_array_add(&gr->vertices,
				sizeof (GLfloat) * 4 * ww->iw * ww->ih);

		for (y = 0; y < ww->ih; y++)
		{
			for (x = 0; x < ww->iw; x++)
			{
				/* Compute vertex coordinates */
				bezierPatchEvaluate(ww->model,
							(x * cell_w) / width,
							(y * cell_h) / height,
							&deformedX,
							&deformedY);

				/* Vertex coord */
				*v++ = deformedX;
				*v++ = deformedY;

				/* Texture coord */
				*v++ = (x * cell_w) / width;
				*v++ = (y * cell_h) / height;
			}
		}
	}
}

static void
wobbly_position_model(struct weston_view *view, struct surface *ws,
			float hw, float hh, float tm[16])
{
	float vx, vy, tx, ty;
	WobblyWindow *ww = ws->ww;

	/* Calculate the vector from center last to center current */
	vx = (ww->model->topLeft.x + hw) - ws->cx;
	vy = (ww->model->topLeft.y + hh) - ws->cy;

	/* Rotate the vector using the matrix inverse */
	tx = tm[0] * vx + tm[1] * vy;
	ty = tm[4] * vx + tm[5] * vy;

	weston_view_set_position(view, tx + ws->x, ty + ws->y);

	ws->x = view->geometry.x;
	ws->y = view->geometry.y;

	ws->cx = ww->model->topLeft.x + hw;
	ws->cy = ww->model->topLeft.y + hh;
}

static void
wobbly_transform_model(struct weston_view *view, GLfloat *v)
{
	struct surface *ws;
	WobblyWindow *ww;
	Model *model;
	float x, y, hw, hh, *m, tm[16] = { 0 };
	int i;

	if (!(ws = get_wobbly_surface(view->surface)))
		return;

	ww = ws->ww;
	model = ww->model;

	hw = ((model->bottomRight.x - model->topLeft.x) / 2.0f);
	hh = ((model->bottomRight.y - model->topLeft.y) / 2.0f);

	/* Compute an inverse matrix for rotation manually
	 * because we want to avoid inversed scale values. */
	m = &view->transform.matrix.d[0];
	tm[0] =  m[5];
	tm[1] = -m[1];
	tm[4] = -m[4];
	tm[5] =  m[0];

	/* Update position for compositor */
	wobbly_position_model(view, ws, hw, hh, tm);

	model->bbox.extents.x1 = MAXSHORT;
	model->bbox.extents.y1 = MAXSHORT;
	model->bbox.extents.x2 = MINSHORT;
	model->bbox.extents.y2 = MINSHORT;

	for (i = 0; i < ww->iw * ww->ih; i++) {
		/* Center model on (0,0) */
		x = (float) *v++ - model->topLeft.x - hw;
		y = (float) *v++ - model->topLeft.y - hh;

		/* Apply transformation */
		*(v - 2) = tm[0] * x + tm[1] * y;
		*(v - 1) = tm[4] * x + tm[5] * y;

		/* Move to global position */
		*(v - 2) += ws->x + (view->surface->width / 2.0f);
		*(v - 1) += ws->y + (view->surface->height / 2.0f);

		/* Compute bounding box */
		if ((float) model->bbox.extents.x1 > (float) *(v - 2))
			model->bbox.extents.x1 = *(v - 2);
		if ((float) model->bbox.extents.x2 < (float) *(v - 2))
			model->bbox.extents.x2 = *(v - 2);

		if ((float) model->bbox.extents.y1 > (float) *(v - 1))
			model->bbox.extents.y1 = *(v - 1);
		if ((float) model->bbox.extents.y2 < (float) *(v - 1))
			model->bbox.extents.y2 = *(v - 1);
		model->bbox_current = 1;

		/* Skip texture coord */
		v += 2;
	}
}

static void
wobbly_paint_view(struct weston_view *view)
{
	struct gl_renderer *gr = get_renderer(view->surface->compositor);
	GLfloat *v;
	GLushort *indices;
	int i, x, y, x_pts;
	struct surface *ws;

	if (!(ws = get_wobbly_surface(view->surface)))
		return;

	x_pts = ws->x_cells + 1;

	v = gr->vertices.data;

	if (!v)
		return;

	indices = malloc(sizeof (GLushort) * ws->x_cells * ws->y_cells * 6);

	if (!indices)
		return;

	for (y = 0, i = 0; y < ws->y_cells; y++)
		for (x = 0; x < ws->x_cells; x++) {
			*(indices + i++) = y * x_pts + x;
			*(indices + i++) = y * x_pts + x + 1;
			*(indices + i++) = (y + 1) * x_pts + x;

			*(indices + i++) = y * x_pts + x + 1;
			*(indices + i++) = (y + 1) * x_pts + x + 1;
			*(indices + i++) = (y + 1) * x_pts + x;
		}

	wobbly_transform_model(view, v);

	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, v);
	glEnableVertexAttribArray(0);

	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof *v, v + 2);
	glEnableVertexAttribArray(1);

	/* 2 (triangles per cell) * 3 (vertices per triangle) *
	   8 (ws->x_cells) * 8 (ws->y_cells) = 384 */
	glDrawElements(GL_TRIANGLES, 384, GL_UNSIGNED_SHORT, indices);

	glDisableVertexAttribArray(1);
	glDisableVertexAttribArray(0);

	gr->vertices.size = 0;

	free(indices);
}

static void
wobbly_done_paint(struct weston_view *view)
{
	weston_view_geometry_dirty(view);
	weston_view_schedule_repaint(view);
}

static void
wobbly_resize_notify(struct weston_view *view)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;
	WobblyWindow *ww;
	int x, y, w, h;

	if (!(ws = get_surface(surface)))
		return;

	if (ws->width == surface->width && ws->height == surface->height)
		return;

	ww = ws->ww;

	x = ws->x = view->geometry.x;
	y = ws->y = view->geometry.y;
	w = ws->width = surface->width;
	h = ws->height = surface->height;

	if (ww->model)
	{
		if (!ww->wobbly)
			modelInitObjects(ww->model, x, y, w, h);

		modelInitSprings(ww->model, x, y, w, h);
	}
}

static void
wobbly_move_notify(struct weston_view *view, int x, int y)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;
	WobblyWindow *ww;
	float dx, dy, tx, ty, *m;

	if (!(ws = get_wobbly_surface(surface)))
		return;

	ww = ws->ww;

	dx = x - ws->last_x;
	dy = y - ws->last_y;

	m = &view->transform.matrix.d[0];
	tx = *(m+0) * dx + *(m+1) * dy;
	ty = *(m+4) * dx + *(m+5) * dy;

	if (ww->grabbed) {
		ww->model->anchorObject->position.x += tx;
		ww->model->anchorObject->position.y += ty;

		ww->wobbly |= WobblyInitial;
		ws->synced = 0;

		if (wl_list_empty(&ws->transform.link))
			wl_list_insert(&view->geometry.transformation_list, &ws->transform.link);
	}

	ws->last_x = x;
	ws->last_y = y;
}

static void
wobbly_grab_notify(struct weston_view *view, int x, int y)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;
	WobblyWindow *ww;
	int gx, gy;

	if (!(ws = get_surface(surface)))
		return;

	ww = ws->ww;

	ws->last_x = x;
	ws->last_y = y;

	if (wobblyEnsureModel(ws))
	{
		Spring *s;
		int	i;

		if (ww->model->anchorObject)
			ww->model->anchorObject->immobile = 0;

		weston_view_from_global(view, x, y, &gx, &gy);
		gx += ww->model->topLeft.x;
		gy += ww->model->topLeft.y;

		ww->model->anchorObject = modelFindNearestObject(ww->model, gx, gy);
		ww->model->anchorObject->immobile = 1;

		ww->grabbed = 1;
		ws->synced = 0;

		for (i = 0; i < ww->model->numSprings; i++)
		{
			s = &ww->model->springs[i];

			if (s->a == ww->model->anchorObject)
			{
				s->b->velocity.x -= s->offset.x * 0.05f;
				s->b->velocity.y -= s->offset.y * 0.05f;
			}
			else if (s->b == ww->model->anchorObject)
			{
				s->a->velocity.x += s->offset.x * 0.05f;
				s->a->velocity.y += s->offset.y * 0.05f;
			}
		}

		ww->wobbly |= WobblyInitial;

		if (wl_list_empty(&ws->transform.link))
			wl_list_insert(&view->geometry.transformation_list, &ws->transform.link);
	}
}

static void
wobbly_ungrab_notify(struct weston_view *view)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;
	WobblyWindow *ww;

	if (!(ws = get_wobbly_surface(surface)))
		return;

	ww = ws->ww;

	if (ww->grabbed)
	{
		if (ww->model)
		{
			if (ww->model->anchorObject)
				ww->model->anchorObject->immobile = 0;

			ww->model->anchorObject = NULL;

			ww->wobbly |= WobblyInitial;
		}

		ww->grabbed = 0;
	}
}

static void
wobbly_init(struct weston_view *view)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;
	WobblyWindow *ww;

	if (get_wobbly_surface(surface))
		return;

	ww = zalloc(sizeof (WobblyWindow));
	if (!ww)
		return;

	ws = zalloc(sizeof *ws);
	if (!ws)
		return;

	ww->model   = 0;
	ww->wobbly  = 0;
	ww->grabbed = 0;
	ww->state   = 0;

	ws->ww = ww;
	ws->surface = surface;

	ws->width = surface->width;
	ws->height = surface->height;
	ws->x = view->geometry.x;
	ws->y = view->geometry.y;
	ws->cx = ws->x + (ws->width / 2.0f);
	ws->cy = ws->y + (ws->height / 2.0f);
	ws->synced = 1;
	ws->x_cells = 8;
	ws->y_cells = 8;
	wl_list_init(&ws->transform.link);
	weston_matrix_init(&ws->transform.matrix);

	if(!wobblyEnsureModel(ws)) {
		 free(ww);
		 free(ws);
		 return;
	}

	wl_list_insert(&wobbly.surface_list, &ws->link);
}

static void
wobbly_fini(struct weston_view *view)
{
	struct weston_surface *surface = view->surface;
	struct surface *ws;

	if (!(ws = get_wobbly_surface(surface)))
		return;

	WobblyWindow *ww = ws->ww;

	if (ww->model)
	{
		pixman_region32_fini(&ww->model->bbox);
		free(ww->model->objects);
		free(ww->model);
	}

	wl_list_remove(&ws->link);

	free(ww);
	free(ws);
}

static int
init(struct weston_compositor *compositor)
{
	wl_list_init(&wobbly.surface_list);

	return 0;
}

static void
fini(struct weston_compositor *compositor)
{
	struct surface *ws, *next;

	wl_list_for_each_safe(ws, next, &wobbly.surface_list, link)
		free(ws);
}

WL_EXPORT struct weston_plugin_interface plugin_interface = {
	.init = init,
	.fini = fini,
	.view_init = wobbly_init,
	.view_fini = wobbly_fini,
	.prepare_paint = wobbly_prepare_paint,
	.add_geometry = wobbly_add_geometry,
	.paint_view = wobbly_paint_view,
	.done_paint = wobbly_done_paint,
	.resize_notify = wobbly_resize_notify,
	.move_notify = wobbly_move_notify,
	.grab_notify = wobbly_grab_notify,
	.ungrab_notify = wobbly_ungrab_notify,
	.compute_bbox = wobbly_compute_bbox,
};
